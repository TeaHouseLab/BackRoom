#!/usr/bin/env fish

function configure
    sed -n "/$argv[1]=/"p "$argv[2]" | sed "s/$argv[1]=//g"
end
function logger-warn
  set_color magenta
  echo "$prefix ! $argv[1..-1]"
  set_color normal
end
function logger-error
  set_color red
  echo "$prefix x $argv[1..-1]"
  set_color normal
end
function logger-info-start
  set_color normal
  echo "$prefix + $argv[1..-1]"
  set_color normal
end
function logger-info-end
  set_color normal
  echo "$prefix - $argv[1..-1]"
  set_color normal
end
function logger-debug
  set_color yellow
  echo "$prefix ? $argv[1..-1]"
  set_color normal
end
function logger-success
  set_color green
  echo "$prefix âˆš $argv[1..-1]"
  set_color normal
end
function logger -d "a lib to print msg quickly"
switch $argv[1]
case 0
  logger-info-start $argv[2..-1]
case 1
  logger-info-end $argv[2..-1]
case 2
  logger-success $argv[2..-1]
case 3
  logger-debug $argv[2..-1]
case 4
  logger-warn $argv[2..-1]
case 5
  logger-error $argv[2..-1]
end
end

function help_echo
 echo '
(./)app [root] [logcat] [enter, manage, host, v/version, h/help]
    root: The root of your backroom storage, all levels will be store here
    
    logcat: Log output level
        Available: [info/*, debug]
    
    enter: Enter a backroom level (Aka. boot a virtual machine)
        Subcommand: [nspawn, chroot, kvm]

            enter chroot: Enter the level with chroot
            (!)This should be only used when configuring a level
            (?)Enter Level with Full control to host, only with file system level containment
            Synatax: enter chroot [target] [exec]
            [target]: uuid/alias of the level
            [exec]: command to be executed

            enter nspawn: Boot the level with nspawn
                Subcommand: [exec, boot]

                    exec: Only try to enter a level and execute commands
                    Synatax: enter nspawn exec [target] [exec]
                    [target]: uuid/alias of the level
                    [exec]: command to be executed
                    Example: backroom ./test debug enter nspawn exec a0d9300af25b473e95198427b2213008 bash

                    boot: Search and boot the level`s init system
                    (!)Need systemd-networkd to setup NAT layer for level(machine)
                    Synatax: enter nspawn boot [target] [ports] [core] [ram] [extra nspawn args]
                    [target]: uuid/alias of the level
                    [ports]: ports to be exposed(format: a-b or a,b or a)
                    Example: backroom ./test debug enter nspawn boot a0d9300af25b473e95198427b2213008 22-25 50% 1024

            enter kvm: Boot the level with qemu+kvm
                Synatax: enter kvm [target] [ports] [core] [ram] [extra qemu args]
                [target]: uuid/alias of the level
                [ports]: ports to be exposed
                Example: backroom ./test debug enter kvm a0d9300af25b473e95198427b2213008 '' 1 1024 -drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd
    
    manage: Manage backroom levels (Aka. setup/configure/manage a machine)
        Subcommand: [level, service]

        manage level: Manage levels
            Subcommand: [add, del, info, tar,list, alias]
            
            level add: Create new levels from remote lxc repo or local disk image
                Subcommand: [rootfs, kvm]
                
                add rootfs: Create levels as rootfs from remote repo(nspawn, chroot)
                    Synatax: add rootfs [remote - http(s) only] [targets]
                    Example: backroom ./test debug manage level add rootfs https://mirrors.bfsu.edu.cn/lxc-images ubuntu:xenial:s390x:default ubuntu:xenial:amd64:default

                add kvm: Create a level as qcow2 disk image from local disk image(kvm+qemu)
                    Synatax: add kvm [target]
                    [target]: Will be the seed(template) of the new level
                    Example: backroom ./test debug manage level add kvm ../template/debian-11.qcow2
                
            level del: Destroy levels
                Syntax: level del [targets]
                (!)Target has to be specific uuid of the level
                Example: backroom ./test debug manage level del f6c23a26881f4bf8bf9aa2af19d38548 a0d9300af25b473e95198427b2213008
                
            level info: Print the info of levels
                Syntax: level info [targets]
                Example: backroom ./test debug manage level info a0d9300af25b473e95198427b2213008

            level tar: Tar or Untar levels (backup levels) into one compressed datapack
                Subcommand:: [tar, untar]

                tar tar: Tar (backup) levels
                Synatax: tar tar [targets]
                Example: backroom . debug manage level tar tar Earth Moon

                tar untar: Untar (import) levels
                Synatax: tar untar [datapack]
                Example: backroom . debug manage level tar untar the_world.brpack

            level list: Print installed and available levels
                Subcommand: [available, installed]
                
                list available: List available levels in remote lxc repo
                Synatax: list available [remote - http(s) only]

                list installed: List installed levels in this root
                Synatax: list installed

            level alias: Set an alias for a level
                Syntax: level alias [target-uuid] [alias name]
                Example: backroom ./test debug manage level alias a0d9300af25b473e95198427b2213008 Earth
        
        manage service: Manage systemd services for levels
            Subcommand: [add, del, edit, power, stat]

            service add: Add services for levels
                Subcommand: [rootfs, kvm]

                add rootfs: Add services for rootfs levels
                    Synatax: add rootfs [targets]
                    Example: backroom ./test debug manage service add rootfs Earth f6c23a26881f4bf8bf9aa2af19d38548

                add kvm: Add services for kvm levels
                    Synatax: add kvm [targets]
                    Example: backroom ./test debug manage service add kvm Earth f6c23a26881f4bf8bf9aa2af19d38548

            service del: Remove services for levels
                Synatax: service del [targets]
                Example: backroom ./test debug manage service del Earth f6c23a26881f4bf8bf9aa2af19d38548

            service edit: Edit services for levels using nano
                Synatax: service edit [targets]
                Example: backroom ./test debug manage service edit Earth

            service power: Power on/off backroom levels through their services
                Synatax: service power [on/off/reboot] [targets]
                Example: backroom ./test debug manage service power on Earth f6c23a26881f4bf8bf9aa2af19d38548

            service stat: Print stats of levels in index
                Synatax: service stat Earth
                Example: backroom ./test debug manage service stat Earth
            
    host: Run backroom as an daemon, provide custom api for easier hosting in OpenVZ style
        Subcommand: [s, ss]

            host s: Run api server without ssl encrypted (Not recommend)
            Synatax: host s [port] [address]
            Example: backroom . debug host s 8080 0.0.0.0

            host ss: Run api server with ssl encrypted
            Synatax: host ss [port] [address] [cert] [key]
            Example: backroom . debug host ss 443 0.0.0.0 /home/fullchain.crt /home/server.key

        [api documents]
        Synatax and URL: [host]/manage/[level, service, power]/[add, del, info, list/del/on, off, reboot]?argvs
        Example: curl \'127.0.0.1:8080/manage/level/add/rootfs?mirror.bfsu.edu.cn/lxc-images&debian:bullseye:amd64:default\'

    v/version: Print version
    
    h/help: Show this msg again'
end

function checkdependence
set 34ylli8_deps_ok 1
for 34ylli8_deps in $argv
    if command -q -v $34ylli8_deps
    else
        set 34ylli8_deps_ok 0
        if test -z "$34ylli8_dep_lost"
            set 34ylli8_deps_lost "$34ylli8_deps $34ylli8_deps_lost"
        else
            set 34ylli8_deps_lost "$34ylli8_deps"
        end
    end
end
if test "$34ylli8_deps_ok" -eq 0
    set_color red
    echo "$prefix [error] Please install "$34ylli8_deps_lost"to run this program"
    set_color normal
    exit
end
end
function checknetwork
  if curl -s -L $argv[1] | grep -q $argv[2]
  else
    set_color red
    echo "$prefix [error] [checknetwork] check failed - check your network connection"
    set_color normal
  end
end
function dir_exist
  if test -d $argv[1]
  else
    set_color red
    echo "$prefix [error] [checkdir] check failed - dir $argv[1] doesn't exist,going to makr one"
    set_color normal
    mkdir $argv[1]
  end
end
function list_menu
ls $argv | sed '\~//~d'
end

function service_add_rootfs
    for level in $argv
        if level_exist "$level"
            if service_exist "$level"
                logger 4 "Service for $level is marked as true in index file"
            else
                echo "[Unit]
Description=BackRoom level $target
After=network.target
StartLimitIntervalSec=15
[Service]
User=root
ExecStart=backroom $(readlink -f $root) info enter nspawn boot $target
SyslogIdentifier=backroom-$target
Restart=on-failure
RestartSec=5
[Install]
WantedBy=multi-user.target" | tee /etc/systemd/system/backroom-$target.service &>/dev/null
                jq -re "(.levels[] | select(.uuid==\"$target\").service) |= \"true\"" "$root/level_index.json" | sponge "$root/level_index.json"
                logger 2 "Service has been created for level $level at /etc/systemd/system/backroom-$target.service"
            end
        else
            logger 5 "Level $level is not found under $root"
        end
    end
end

function service_stat
    for level in $argv
        if level_exist "$level"
            if service_exist "$level"
                set power_stat (jq -re ".levels[] | select(.uuid==\"$target\").stat" "$root/level_index.json")
                if test "$power_stat" = up
                    set_color green
                    echo "$level is up"
                    set_color normal
                else
                    if test "$power_stat" = down
                        set_color red
                        echo "$level is down"
                        set_color normal
                    else
                        set_color yellow
                        echo "$level is in a unknown status -> $power_stat"
                        set_color normal
                    end
                end
            else
                logger 5 "Service file for level $target is not found"
            end
        else
            logger 5 "Level $target is not found under $root"
        end
    end
end

function service_edit
    for level in $argv
        if level_exist "$level"
            nano /etc/systemd/system/backroom-$target.service
            systemctl daemon-reload
            logger 2 "Reconfigured level $level at /etc/systemd/system/backroom-$target.service"
        else
            logger 5 "Level $level is not found under $root"
        end
    end
end

function service_add_kvm
    set pwd (pwd)
    for level in $argv
        if level_exist "$level"
            if service_exist "$level"
                logger 4 "Service for $level is marked as true in index file"
            else
                echo "[Unit]
Description=BackRoom level $target
After=network.target
StartLimitIntervalSec=15
[Service]
User=root
ExecStart=backroom $pwd/$root info enter kvm $target
SyslogIdentifier=backroom-$target
Restart=on-failure
RestartSec=5
[Install]
WantedBy=multi-user.target" | tee /etc/systemd/system/backroom-$target.service &>/dev/null
                jq -re "(.levels[] | select(.uuid==\"$target\").service) |= \"true\"" "$root/level_index.json" | sponge "$root/level_index.json"
                logger 2 "Service has been created for level $level at /etc/systemd/system/backroom-$target.service"
            end
        else
            logger 5 "Level $level is not found under $root"
        end
    end
end

function service_del
    for level in $argv
        if level_exist "$level"
            if service_exist "$level"
                rm /etc/systemd/system/backroom-$target.service
                jq -re "(.levels[] | select(.uuid==\"$target\").service) |= \"false\"" "$root/level_index.json" | sponge "$root/level_index.json"
                logger 2 "Service file for level $level has been removed from /etc/systemd/system/backroom-$target.service"
            else
                logger 5 "Service file for level $level is not found"
            end
        else
            logger 5 "Level $level is not found under $root"
        end
    end
end

function service_power
    switch $argv[1]
        case on
            for level in $argv[2..-1]
                if level_exist "$level"
                    if service_exist "$level"
                        if test (jq -er ".levels[] | select(.uuid==\"$target\") .stat" "$root/level_index.json") = down
                            if systemctl start backroom-$target; and systemctl enable backroom-$target
                                jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"up\"" "$root/level_index.json" | sponge "$root/level_index.json"
                                logger 2 "Level $level is up and enabled at startup"
                            else
                                logger 5 "Failed to bring up level $level"
                            end
                        else
                            if test (jq -er ".levels[] | select(.uuid==\"$target\") .stat" "$root/level_index.json") = up
                                logger 4 "Level $level has already up"
                            else
                                logger 5 "Unknown stat code for level $level"
                                continue
                            end
                        end
                    else
                        if test "$(jq -re ".levels[] | select(.uuid=\"$target\").variant" "$root/level_index.json")" = kvm_machine
                            service_add_kvm "$target"
                        else
                            service_add_rootfs "$target"
                        end
                        if systemctl start backroom-$target; and systemctl enable backroom-$target
                            jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"up\"" "$root/level_index.json" "$root/level_index.json"
                            logger 2 "Level $level is up and enabled at startup"
                        else
                            logger 5 "Failed to bring up level $level"
                        end
                    end
                else
                    logger 5 "Level $level is not found under $root"
                end
            end
        case off
            for level in $argv[2..-1]
                if level_exist "$level"
                    if service_exist "$level"
                        if test (jq -er ".levels[] | select(.uuid==\"$target\") .stat" "$root/level_index.json") = up
                            if systemctl stop backroom-$target; and systemctl disable backroom-$target
                                jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"down\"" "$root/level_index.json" | sponge "$root/level_index.json"
                                logger 2 "Level $level is down and disabled at startup"
                            else
                                logger 5 "Failed to put down level $level"
                            end
                        else
                            if test (jq -er ".levels[] | select(.uuid==\"$target\").stat" "$root/level_index.json") = down
                                logger 4 "Level $level has already down"
                            else
                                logger 5 "Unknown stat code for level $level"
                                continue
                            end
                        end
                    else
                        logger 4 "Service for level $level is not found"
                    end
                else
                    logger 5 "Level $level is not found under $root"
                end
            end
        case reboot
            for level in $argv[2..-1]
                service_power off $argv[2..-1]
                service_power on $argv[2..-1]
            end
        case '*'
            logger 5 "Option $argv[1] not found at backroom.service.power"
    end
end

function service_exist
    set target $argv[1]
    if level_exist "$target"
        if jq -er ".levels[] | select(.uuid==\"$target\") | select(.service==\"false\")" "$root/level_index.json" &>/dev/null
            if test -e /etc/systemd/system/backroom-$target.service
                return 0
            else
                return 1
            end
        else
            return 0
        end
    else
        return 1
    end
end

function level_del
    for level in $argv
        if level_exist "$level"
            mount_utils umount "$target"
            service_power off "$target"
            service_del "$target"
            if rm -rf "$root/$target"
                jq -er "del(.levels[] | select(.uuid == \"$target\"))" "$root/level_index.json" | sponge "$root/level_index.json"
                logger 2 "Level $level at "$root/$target" has been destroyed"
            else
                logger 5 "Failed to destroy level $level"
            end
        else
            logger 5 "Level $level is not found under $root"
            continue
        end
    end
end

function level_add_kvm
    set seed $argv[1]
    set uuid (cat /proc/sys/kernel/random/uuid | sed 's/-//g')
    set timestamp (date -u +"%Y-%m-%d-%H:%M:%S")
    if file $seed | grep -qs Image
        if cp $seed $uuid
            jq ".levels |= . + [{\"uuid\": \"$uuid\" ,\"variant\": \"kvm_machine\",\"type\": \"disk\" , \"alias\": \"\", \"date\": \"$timestamp\", \"service\": \"false\", \"stat\": \"down\"}]" "$root/level_index.json" | sponge "$root/level_index.json"
            logger 2 "Level $uuid spawned"
        else
            logger 5 "Failed to spawn level from $seed"
        end
    else
        logger 5 "This is not a disk image"
        return 1
    end
end

function level_list
    switch $argv[1]
        case available
            set remote $argv[2]
            if test -z $remote
                if test -z (jq -re ".remote " "$root/level_index.json")
                    logger 5 "No remote configured"
                    exit 1
                else
                    if test "$logcat" = debug
                        logger 3 "Remote set from storage"
                    end
                    set remote (jq -re ".remote " "$root/level_index.json")
                end
            else
                if test -z (jq -re ".remote " "$root/level_index.json")
                    jq -re ".remote |= \"$remote\"" "$root/level_index.json" | sponge "$root/level_index.json"
                    if test "$logcat" = debug
                        logger 3 "Remote stored"
                    end
                end
            end
            if test "$logcat" = debug
                logger 3 "Set remote lxc repo to $remote"
                logger 3 "Testing connectivity to remote"
                logger 3 "Test if index file is available in $root"
            end
            if test "$(curl -sL $remote/streams/v1/images.json | jq -r .content_id)" = images
                if test "$logcat" = debug
                    logger 3 "Connected to remote"
                end
            else
                logger 5 "This remote repo does not contain lxc images or it's down currently"
                exit 1
            end
            set meta (curl -sL $remote/streams/v1/images.json | jq -r '.products')
            echo $meta | jq -r 'keys'
        case installed
            jq -er '[.levels[] | {"uuid": .uuid, "variant": .variant, "alias": .alias}]'  "$root/level_index.json"
        case '*'
            logger 5 "Option $argv[1] not found at backroom.level_list"
    end
end

function level_info
    for level in $argv
        if level_exist "$level"
            jq -er ".levels[] | select(.uuid==\"$target\")" "$root/level_index.json"
        else
            logger 5 "Level $level is not found under $root"
        end
    end
end

function level_spawn
    set target $argv[1]
    if test "$logcat" = debug
        logger 3 "Spawning $target"
        sh -c "echo 'safety:x:1000:1000:safety,,,:/home/safety:/bin/sh' >> $root/$target/etc/passwd
            echo 'safety:x:1000:' >> $root/$target/etc/group
            echo 'safety:!:0:0:99999:7:::' >> $root/$target/etc/shadow
            mkdir -p $root/$target/home/safety
            rm -f $root/$target/etc/hostname
            echo $target > $root/$target/etc/hostname
            echo 127.0.0.1  $target >> $root/$target/etc/hosts
            cp -f --remove-destination /etc/resolv.conf $root/$target/etc/resolv.conf"
    else
        sh -c "echo 'safety:x:1000:1000:safety,,,:/home/safety:/bin/sh' >> $root/$target/etc/passwd
            echo 'safety:x:1000:' >> $root/$target/etc/group
            echo 'safety:!:0:0:99999:7:::' >> $root/$target/etc/shadow
            mkdir -p $root/$target/home/safety
            rm -f $root/$target/etc/hostname
            echo $target > $root/$target/etc/hostname
            echo 127.0.0.1  $target >> $root/$target/etc/hosts
            cp -f --remove-destination /etc/resolv.conf $root/$target/etc/resolv.conf" &>/dev/null
    end
    if [ "$logcat" = debug ]
        logger 3 "Configuring $target"
        br_chroot $target /bin/sh -c '/bin/chown -R safety:safety /home/safety
            /bin/chmod -R 755 /home/safety & echo "safety    ALL=(ALL:ALL) ALL" >> /etc/sudoers
            echo "0d7882da60cc3838fabc4efc62908206" > /etc/machine-id
            (crontab -l 2>/dev/null; echo @reboot ip link set host0 name eth0) | crontab -'
    else
        br_chroot $target /bin/sh -c '/bin/chown -R safety:safety /home/safety
            /bin/chmod -R 755 /home/safety & echo "safety    ALL=(ALL:ALL) ALL" >> /etc/sudoers
            echo "0d7882da60cc3838fabc4efc62908206" > /etc/machine-id
            (crontab -l 2>/dev/null; echo @reboot ip link set host0 name eth0) | crontab -' &>/dev/null
    end
    return 0
end
function level_index_db
    if test -e $root
        if test -d $root
            if test -w $root; and test -r $root
                if test -e "$root/level_index.json"
                    if test "$logcat" = debug
                        logger 3 "Index is available"
                    end
                else
                    if echo '{"remote": "", "levels": []}' >"$root/level_index.json"
                        if test "$logcat" = debug
                            logger 3 "Index is available"
                        end
                    else
                        logger 5 "Can not create index file in $root"
                        exit 1
                    end
                end
            else
                logger 5 "root => $root is not Readable/Writable"
                exit 1
            end
        else
            logger 5 "root => $root is not a diretory file"
            exit 1
        end
    else
        logger 5 "root => $root is not found"
        exit 1
    end
end

function level_seed
    set target $argv[1]
    set meta (curl -sL $remote/streams/v1/images.json | jq -r '.products')
    set latest (echo $meta | jq -r ".[\"$target\"].versions|keys|.[]" | tail -n1)
    set path (echo $meta | jq -r ".[\"$target\"].versions|.[\"$latest\"].items |.[\"root.tar.xz\"].path")
    if echo "$path" | grep -qs null
        logger 5 "Target does not exist in remote repo"
        return 1
    else
        set sha256 (echo $meta | jq -r ".[\"$target\"].versions|.[\"$latest\"].items |.[\"root.tar.xz\"].sha256")
    end
    if test "$logcat" = debug
        logger 3 "Testing if package folder exist"
    end
    if test -d "$root/.package"
        if test "$logcat" = debug
            logger 3 "Package folder is existed"
        end
    else
        logger 4 "Package folder is not existed, trying to create it"
        if mkdir -p "$root/.package"
        else
            logger 5 "Can not create the package cache folder"
            exit 1
        end
    end
    if test -e "$root/.package/$target.level"
        if test "$(sha256sum $root/.package/$target.level | awk -F ' ' '{print $1}')"
            logger 2 "Level package $target checked, using cached package"
            return 0
        else
            logger 4 "Level package $target check sha256 failed"
            rm "$root/.package/$target.level"
            level_seed $target
        end
    else
        if sudo -E curl --progress-bar -L -o "$root/.package/$target.level" "$remote/$path"
            if test "$(sha256sum $root/.package/$target.level | awk -F ' ' '{print $1}')"
                logger 2 "Level package $target checked"
                return 0
            else
                logger 4 "Level package $target check sha256 failed"
                return 1
            end
        end
    end
end

function level_exist
    set target $argv[1]
    set level_json (cat "$root/level_index.json")
    if echo "$level_json" | jq -er ".levels[] | select(.uuid==\"$target\")" &>/dev/null
        set target (echo "$level_json" | jq -r ".levels[] | select(.uuid==\"$target\").uuid")
        if test (echo "$level_json" | jq -r ".levels[] | select(.uuid==\"$target\").variant") = kvm_machine
            if test -e $root/$target
                return 0
            else
                return 1
            end
        else
            if test -d $root/$target
                return 0
            else
                return 1
            end
        end
    else
        if echo "$level_json" | jq -er ".levels[] | select(.alias==\"$target\")" &>/dev/null
            set target (echo "$level_json" | jq -r ".levels[] | select(.alias==\"$target\").uuid")
            if test (echo "$level_json" | jq -r ".levels[] | select(.uuid==\"$target\").variant") = kvm_machine
                if test -e $root/$target
                    return 0
                else
                    return 1
                end
            else
                if test -d $root/$target
                    return 0
                else
                    return 1
                end
            end
        else
            return 1
        end
    end
end

function level_tar
    set timestamp (date -u +"%Y-%m-%d-%H-%M-%S")
    switch $argv[1]
        case tar
            echo "[]" >"$root/brpack.info"
            set counter 1
            for level in $argv[2..-1]
                if level_exist $level
                    set level_info (jq -er ".levels[] | select(.uuid==\"$target\")" "$root/level_index.json")
                    jq ". + [$level_info]" "$root/brpack.info" | sponge "$root/brpack.info"
                    set level_list[$counter] "$target"
                    set counter (math "$counter+1")
                else
                    logger 5 "Level $level is not found under $root"
                    set level_onboard false
                end
            end
            if test "$level_onboard" = false
                rm "$root/brpack.info"
                logger 5 "You have levels aren't existed under this root"
                return 1
            else
                logger 0 "Start packing levels"
                if tar -I 'zstd -T0' -cf "$root/$timestamp.brpack" brpack.info $level_list
                    rm "$root/brpack.info" 
                    logger 2 "Level onboard, stored at $root/$timestamp.brpack"
                else
                    rm "$root/$timestamp.brpack" "$root/brpack.info"
                    logger 5 "Failed to package levels"
                end
            end
        case untar
            set random (random)
            mkdir "$root/"$random"untar"
            logger 0 "Start untaring levels"
            if tar -I 'zstd -T0' -xf $argv[2] -C "$root/"$random"untar"
                set brpack_json (cat "$root/"$random"untar/brpack.info")
                for level in (echo "$brpack_json" | jq -er ".[] | .uuid")
                    set level_info (echo "$brpack_json" | jq -er ".[] | select(.uuid==\"$level\")")
                    mv "$root/"$random"untar/$level" "$root"
                    jq ".levels |= . + [$level_info]" "$root/level_index.json" | sponge "$root/level_index.json"
                end
                rm -rf "$root/"$random"untar"
                logger 2 "Level merged into root $root"
            else
                rm -rf "$root/"$random"untar"
                logger 5 "Failed to untar $argv[2]"
            end
        case '*'
            logger 5 "Option $argv[1] not found at backroom.level.tar"
    end
end

function level_add_rootfs
    set -x remote $argv[1]
    set -x targets $argv[2..-1]
    set -x timestamp (date -u +"%Y-%m-%d-%H:%M:%S")
    set -x check
    if test -z $remote
        if test -z (jq -re ".remote " "$root/level_index.json")
            logger 5 "No remote configured"
            exit 1
        else
            if test "$logcat" = debug
                logger 3 "Remote set from storage"
            end
            set remote (jq -re ".remote " "$root/level_index.json")
        end
    else
        if test -z (jq -re ".remote " "$root/level_index.json")
            jq -re ".remote |= \"$remote\"" "$root/level_index.json" | sponge "$root/level_index.json"
            if test "$logcat" = debug
                logger 3 "Remote stored"
            end
        end
    end
    if test "$logcat" = debug
        logger 3 "Set remote lxc repo to $remote"
        logger 3 "Testing connectivity to remote"
        logger 3 "Test if index file is available in $root"
    end
    if test "$(curl -sL $remote/streams/v1/images.json | jq -r .content_id)" = images
        if test "$logcat" = debug
            logger 3 "Connected to remote"
        end
    else
        logger 5 "This remote repo does not contain lxc images or it's down currently"
        exit 1
    end
    for target in $targets
        if level_seed $target
        else
            return 1
            continue
        end
        set uuid (cat /proc/sys/kernel/random/uuid | sed 's/-//g')
        mkdir $uuid
        tar --force-local -xf "$root/.package/$target.level" -C "$root/$uuid"
        jq ".levels |= . + [{\"uuid\": \"$uuid\" ,\"variant\": \"$target\",\"type\": \"rootfs\" , \"alias\": \"\", \"date\": \"$timestamp\", \"service\": \"false\", \"stat\": \"down\"}]" "$root/level_index.json" | sponge "$root/level_index.json"
        if level_spawn $uuid
            logger 2 "Level $uuid spawned"
        else
            continue
        end
    end
end

function level_alias
    set target $argv[1]
    set alias $argv[2]
    if level_exist $target
        if jq -re "(.levels[] | select(.uuid==\"$target\").alias) |= \"$alias\"" "$root/level_index.json" | sponge "$root/level_index.json"
            logger 2 "Set alias $alias for level $target"
        else
            logger 5 "Failed to set alias for level $target"
        end
    else
        logger 5 "Level $target is not found under $root"
    end
end

function service
    switch $argv[1]
        case add
            switch $argv[2]
                case kvm
                    service_add $argv[3..-1]
                case rootfs
                    service_add_rootfs $argv[3..-1]
            end
        case del
            service_del $argv[2..-1]
        case stat
            service_stat $argv[2..-1]
        case power
            service_power $argv[2..-1]
        case edit
            service_edit $argv[2..-1]
        case '*'
            logger 5 "Option $argv[1] not found at backroom.service"
    end
end

function level
    switch $argv[1]
        case add
            switch $argv[2]
                case kvm
                    level_add_kvm $argv[3..-1]
                case rootfs
                    level_add_rootfs $argv[3..-1]
                case '*'
                    logger 5 "Option $argv[1] not found at backroom.level.add"
            end
        case del
            level_del $argv[2..-1]
        case info
            level_info $argv[2..-1]
        case tar
            level_tar $argv[2..-1]
        case list
            level_list $argv[2..-1]
        case alias
            level_alias $argv[2..-1]
        case '*'
            logger 5 "Option $argv[1] not found at backroom.level"
    end
end

function br_chroot
    set target $argv[1]
    if level_exist "$target"
    else
        logger 5 "Level $target is not found under $root"
        exit 1
    end
    mount_utils mount "$target"
    logger 0 "Entering level $target"
    chroot "$root/$target" $argv[2..-1]
    mount_utils umount "$target"
end

function br_nspawn
    set target $argv[2]
    set target_arg $argv[6..-1]
    if level_exist "$target"
    else
        logger 5 "Level $target is not found under $root"
        exit 1
    end
    jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"up\"" "$root/level_index.json" | sponge "$root/level_index.json"
    switch $argv[1]
        case exec
            sudo systemd-nspawn --resolv-conf=off -q -D "$root/$target" $target_arg $argv[3..-1]
        case boot
            if setup_network
            else
                logger 5 "Failed to setup network"
                exit 1
            end
            set target_port $argv[3]
            set target_core $argv[4]
            set target_mem $argv[5]
            if test -z "$target_port"
                sudo systemd-nspawn --property=MemoryMax=$target_mem --property=CPUQuota=$target_core --resolv-conf=off $target_arg -bnq -D "$root/$target"
            else
                set port_range $target_port
                if echo $port_range | grep -qs -
                    set -e port_mapping_tcp
                    set -e port_mapping_udp
                    set -e port_mapping
                    set port_counter 0
                    for port_arrary in (seq (echo $port_range | awk -F "-" '{print $1}') (echo $port_range | awk -F "-" '{print $2}'))
                        set port_counter (math $port_counter+1)
                        set port_mapping_tcp[$port_counter] "-ptcp:$port_arrary"
                        set port_mapping_udp[$port_counter] "-pudp:$port_arrary"
                    end
                else
                    if echo $port_range | grep -qs ,
                        set -e port_mapping_tcp
                        set -e port_mapping_udp
                        set -e port_mapping
                        set port_counter 0
                        for port_arrary in (echo $port_range | string split ,)
                            set port_counter (math $port_counter+1)
                            set port_mapping_tcp[$port_counter] "-ptcp:$port_arrary"
                            set port_mapping_udp[$port_counter] "-pudp:$port_arrary"
                        end
                    else
                        set port_mapping_tcp "-ptcp:$target_port"
                        set port_mapping_udp "-pudp:$target_port"
                    end
                end
                sudo systemd-nspawn --property=MemoryMax=$target_mem --property=CPUQuota=$target_core --resolv-conf=off $target_arg $port_mapping_tcp $port_mapping_udp -bnq -D "$root/$target"
            end
        case '*'
            logger 5 "Option $argv[1] not found at backroom.nspawn"
            return 1
    end
    jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"down\"" "$root/level_index.json" | sponge "$root/level_index.json"
end

function mount_utils
    set target $argv[2]
    function mount_rw
        for mount_target in $argv
            if test "$logcat" = debug
                logger 3 "Mounting $mount_target to $root/$target$mount_target"
            end
            if grep -qs "$root/$target$mount_target" /proc/mounts
            else
                mount -o bind,rw "$mount_target" "$root/$target$mount_target"
            end
        end
    end
    function umount_rw
        for umount_target in $argv
            if test "$logcat" = debug
                logger 3 "Unmounting $umount_target $root/$target$umount_target"
            end
            if grep -qs "$root/$target$umount_target" /proc/mounts
                umount -l "$root/$target$umount_target"
            end
            if grep -qs /dev/pts /proc/mounts
            else
                mount devpts /dev/pts -t devpts
            end
        end
    end
    switch $argv[1]
        case mount
            mount_rw /dev /dev/pts /proc /sys
        case umount
            umount_rw /dev /dev/pts /proc /sys
        case '*'
            logger 5 "Option $argv[1] not found at backroom.chroot.mount_utils"
            return 1
    end
end

function setup_network
    if test "$logcat" = debug
        logger 3 "Starting Setup Nat network for levels"
    end
    if systemctl is-active --quiet systemd-networkd
    else
        if test (systemctl list-unit-files 'systemd-networkd*' | wc -l) -gt 3
            sudo systemctl start systemd-networkd
        else
            return 1
        end
    end
end

function br_kvm
    set target $argv[1]
    if level_exist "$target"
    else
        logger 5 "Level $target is not found under $root"
        exit 1
    end
    jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"up\"" "$root/level_index.json" | sponge "$root/level_index.json"
    set target_port $argv[2]
    set target_core $argv[3]
    set target_mem $argv[4]
    set target_arg $argv[5..-1]
    if test -z "$target_port"
        qemu-system-x86_64 --enable-kvm -smp "$target_core" -m "$target_mem" $target_arg -hda "$root/$target"
    else
        set port_range $target_port
        if echo $port_range | grep -qs -
            set -e port_mapping_tcp
            set -e port_mapping_udp
            set -e port_mapping
            set port_counter 0
            for port_arrary in (seq (echo $port_range | awk -F "-" '{print $1}') (echo $port_range | awk -F "-" '{print $2}'))
                set port_counter (math $port_counter+1)
                set port_mapping_tcp[$port_counter] ",hostfwd=tcp::$port_arrary-:$port_arrary"
                set port_mapping_udp[$port_counter] ",hostfwd=udp::$port_arrary-:$port_arrary"
            end
        else
            if echo $port_range | grep -qs ,
                set -e port_mapping_tcp
                set -e port_mapping_udp
                set -e port_mapping
                set port_counter 0
                for port_arrary in (echo $port_range | string split ,)
                    set port_counter (math $port_counter+1)
                    set port_mapping_tcp[$port_counter] ",hostfwd=tcp::$port_arrary-:$port_arrary"
                    set port_mapping_udp[$port_counter] ",hostfwd=udp::$port_arrary-:$port_arrary"
                end
            else
                set port_mapping_tcp ",hostfwd=tcp::$target_port-:$target_port"
                set port_mapping_udp ",hostfwd=udp::$target_port-:$target_port"
            end
        end
        qemu-system-x86_64 --enable-kvm -smp "$target_core" -m "$target_mem" -nic user$port_mapping_tcp $port_mapping_udp $target_arg -hda "$root/$target"
    end
    jq -re "(.levels[] | select(.uuid==\"$target\").stat) |= \"down\"" "$root/level_index.json" | sponge "$root/level_index.json"
end

function logicpipe
    while read request_raw
        set request_raw_process (echo $request_raw | tr '\r' ' ')
        set request "$request $request_raw_process"
        if test "$request_raw" = \r
            break
        end
    end
    set ip $argv[1]
    set port $argv[2]
    set path $argv[3]
    set dir $argv[4]
    set -x output
    set request_path (echo $request | tr ' ' '\n' | awk '/GET/{getline; print}')
    set 200 "HTTP/1.1 200 OK
Content-Type:*/*; charset=UTF-8"
    set 403 "HTTP/1.1 403 Forbidden
Content-Type:*/*; charset=UTF-8"
    set 404 "HTTP/1.1 404 Not Found
Content-Type:*/*; charset=UTF-8"
    set 500 "HTTP/1.1 500 Internal Server Error
Content-Type:*/*; charset=UTF-8"
    function status_return
        if test "$argv[1]" = 500
            echo -e "$500\r\n"
            echo "{\"action\": false, \"output\": \"$output\"}"
        else
            echo -e "$$argv[1]\r\n"
        end
    end
    if echo $request_path | grep -qs "?"
        set request_path (echo $request | tr ' ' '\n' | awk '/GET/{getline; print}' | awk -F "?" '{print $1}')
        set request_argv (echo $request | tr ' ' '\n' | awk '/GET/{getline; print}' | awk -F "?" '{print $2}')
        set arg true
    end
    switch $request_path
        case '/manage/*'
            set level_1 (echo "$request_path" | sed 's/\/manage\///g')
            switch $level_1
                case 'level/*'
                    set level_2 (echo "$level_1" | sed 's/level\///g')
                    switch $level_2
                        case 'add/*'
                            set level_3 (echo "$level_2" | sed 's/add\///g')
                            switch $level_3
                                case 'rootfs*'
                                    if set output ($path $dir info manage level add rootfs (echo "$request_argv" | string split '&'))
                                        status_return 200
                                        echo "{\"succeeded\": true, \"uuid\": \"$(echo $output | awk -F ' ' '{print $(NF-2)}')\"}"
                                    else
                                        status_return 500
                                    end
                                case 'kvm*'
                                case '*'
                                    status_return 404
                                    echo 'Unknown action at backroom.manage.level.add'
                            end
                        case 'del*'
                            if set output ($path $dir info manage level del (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "{\"succeeded\": true}"
                            else
                                status_return 500
                            end
                        case 'info*'
                            if set output ($path $dir info manage level info (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "$output"
                            else
                                status_return 500
                            end
                        case 'list/*'
                            set level_3 (echo "$level_2" | sed 's/list\///g')
                            switch $level_3
                                case 'available*'
                                    if set output ($path $dir info manage level list available (echo "$request_argv" | string split '&'))
                                        status_return 200
                                        echo $output
                                    else
                                        status_return 500
                                    end
                                case installed
                                    if set output ($path $dir info manage level list installed)
                                        status_return 200
                                        echo $output
                                    else
                                        status_return 500
                                    end
                            end
                        case '*'
                            status_return 404
                            echo 'Unknown action at backroom.manage.level'
                    end
                case 'service/*'
                    set level_2 (echo "$level_1" | sed 's/service\///g')
                    switch $level_2
                        case 'del*'
                            if set output ($path $dir info manage service del (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "{\"succeeded\": true}"
                            else
                                status_return 500
                            end
                        case '*'
                            status_return 404
                            echo 'Unknown action at backroom.manage.service'
                    end
                case 'power/*'
                    set level_2 (echo "$level_1" | sed 's/power\///g')
                    switch $level_2
                        case 'on*'
                            if set output ($path $dir info manage service power on (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "{\"succeeded\": true}"
                            else
                                status_return 500
                            end
                        case 'off*'
                            if set output ($path $dir info manage service power off (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "{\"succeeded\": true}"
                            else
                                status_return 500
                            end
                        case 'reboot*'
                            if set output ($path $dir info manage service power reboot (echo "$request_argv" | string split '&'))
                                status_return 200
                                echo "{\"succeeded\": true}"
                            else
                                status_return 500
                            end
                        case '*'
                            status_return 404
                            echo 'Unknown action at backroom.manage.power'
                    end
                case '*'
                    status_return 404
                    echo 'Unknown action at backroom.manage'
            end
        case '*'
            status_return 404
            echo 'Unknown action at backroom.main'
    end
end

function api
    set path (status --current-filename)
    set dir (pwd)
    set logicpipe (mktemp)
    sed -n '/^function logicpipe/,/^end/p' $path | sed '1d; $d' | tee "$logicpipe" &>/dev/null
    chmod +x "$logicpipe"
    if test "$logcat" = debug
        logger 2 "Logicpipe loaded"
    end
    trap "logger 2 Main thread stopped && rm $logicpipe" INT
    set port $argv[2]
    set ip $argv[3]
    switch $argv[1]
        case ss
            set cert $argv[4]
            set key $argv[5]
            if test -e "$cert"; or test -e "$key";or test -r "$cert"; or test -r "$key"
                logger 5 "Cert or key file is not available or readable"
            else
                socat openssl-listen:$port,bind=$ip,cert=$cert,key=$key,verify=0,reuseaddr,fork,end-close EXEC:"fish $logicpipe $ip $port "$path" "$dir""
            end
        case s
            socat tcp-listen:$port,bind=$ip,reuseaddr,fork,end-close EXEC:"fish $logicpipe $ip $port "$path" "$dir""
        case '*'
            logger 5 "Option $argv[1] not found at backroom.host"
    end
end

echo Build_Time_UTC=2022-09-08_05:59:52
set -x prefix "[BackRoom]"
set -x codename Joshua
set -x ver 1
set -x target
set -x root $argv[1]
set -x logcat $argv[2]
if test -z $root
    set root .
end
if test -z $logcat
    set logcat info
end
checkdependence jq curl sponge nano systemd-nspawn zstd tar xz
switch $argv[3]
    case enter
        level_index_db
        switch $argv[4]
            case nspawn
                br_nspawn $argv[5..-1]
            case chroot
                br_chroot $argv[5..-1]
            case kvm
                br_kvm $argv[5..-1]
            case '*'
                logger 5 "Option $argv[1] not found at backroom.enter"
        end
    case manage
        level_index_db
        switch $argv[4]
            case service
                service $argv[5..-1]
            case level
                level $argv[5..-1]
            case '*'
                logger 5 "Option $argv[1] not found at backroom.manage"
        end
    case host
        level_index_db
        api $argv[4..-1]
    case v version
        logger 1 "$codename@build$version"
    case h help '*'
        help_echo
end
